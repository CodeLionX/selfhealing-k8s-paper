% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Introduction}\label{sec:introduction}
  % cloud computing
  Cloud Computing has become the de-facto standard of deploying new scalable applications.
  Companies chose cloud over on-premise or self-hosted environments, because they can deploy their applications more flexible, with higher and dynamically scalable performance, and because prices are very competitive~\cite{ToffettiMicroservices}.
  However, present cloud environments have to deal with heterogeneous resources and an ever-increasing scale.
  With this growing complexity failures are more likely to occur and software engineers have to design applications with that in mind.
  This can be achieved via replication, containment, isolation, and monitoring paired with responsive actions to failures~\cite{reactivemanifesto}.

  % microservices
  One way to realize containment and isolation of software components in a scalable way are microservice architectures.
  In this approach, the software application is decomposed along business domain boundaries into small, lightweight, autonomous services.
  Each service runs as its own application decoupled from the other services and acts as a scaling unit.
  Services communicate through lightweight REST APIs or asynchronous message queues.
  Microservice architectures embrace failure.
  If a service relies on another services, it is aware that the other service may not be available or the connection may be slow and the service can deal with the failures~\cite{microservices}.

  % orchestration --> docker and kubernetes
  For those complex distributed software systems consisting of hundreds of microservices, deployment and management gets more complex as well.
  The service management can be simplified by executing the microservices isolated from each other in containers, such as Docker containers~\cite{docker}.
  Container orchestration tools, such as \gls{kubernetes}~\cite{kubernetes}, can further be used for the deployment, scaling, and management of the containerized distributed microservice applications.

  % self-adaptive systems
  The increasing complexity of modern software systems motivated the development of self-adaptive systems.
  Those systems introduce an autonomous behavior that takes decisions at runtime and manages the complex underlying software system.
  This allows the software systems to adapt to unpredictable system changes and changing environments.
  Self-adaptive systems combine four self properties, as defined by \citeauthor{Ganek}~\cite{Ganek}:

  \begin{description}
    \item[self-configuring] The systems adapt automatically to dynamically changing environments (\enquote{on-the-fly}).
    \item[self-healing] The systems discover, diagnose, and react to failures reducing disruptions and enabling continuous availability.
    \item[self-optimization] Systems efficiently maximize resource utilization.
    \item[self-protection] Systems anticipate, detect, identify, and protect themselves from attacks.
  \end{description}

  This list has been continuously extended and the extended properties are now referred to as self-* properties~\cite{PsaierSurvey}.

  % self-healing
  One essential part of a self-adaptive systems are its self-healing capabilities, which we will focus on in this paper.
  Self-healing systems monitor the running application and try to keep the system in an healthy state to increase availability and maintain the essential functionality.
  Therefore, they have to be fault tolerant, mask temporary failures, and recover from them in a finite amount of time to reach the healthy system state again.
  In cloud environments, self-healing techniques are already used in the form of approaches and tools that try to achieve continuous availability for cloud services.
  Those tools detect disruptions, diagnose failures and recover from them by applying an appropriate strategy~\cite{PsaierSurvey}.
  \Gls{kubernetes} is one of those tools.

  % contribution
  In this paper, we compare the solutions and approaches proposed in self-healing research literature with the way \gls{kubernetes} implements self-healing capabilities.
  We show, which self-healing concepts are already implemented by \gls{kubernetes} and where there are still open issues and limitations.

  % outline
  The rest of this paper is structures as follows:
  \Cref{sec:self-healing} introduces the concept of self-healing systems and summarizes recent research literature in this area.
  In \cref{sec:kubernetes}, we quickly present base concepts and the architecture of \gls{kubernetes}.
  Using those base concepts, we can then explain, how \gls{kubernetes} implements self-healing capabilities in \cref{sec:self-healing-kubernetes}.
  The discussion of benefits and limitations of \gls{kubernetes}' self-healing capabilities follows in \cref{sec:discussion}.
  Before we conclude the paper in \cref{sec:conclusion}, we briefly go through the related work in \cref{sec:related-work}.

  % where should I put this ...
  \textbf{Where should I put this paragraph?}
  While systems and software components can fail in various ways and research has come up with general failure classifications and resolutions~\cite[Tab.~1]{PsaierSurvey}, failures in cloud environments can be reduced to one failure: a node or component is detected unreachable.
  Although an unreachable node can have different root causes on the infrastructure level, the impact on the system is the same and we have no control about the infrastructure in a cloud deployment.
  This means that we have to find other ways besides repairing the infrastructure to heal from those failures.
  Node failures can be detected via heartbeat messages or latency metrics and a common recovery strategy used is the restart of the software that was running on the node on another node.
  % ...
