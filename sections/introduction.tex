% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Introduction}\label{sec:introduction}

  Cloud Computing has become the de-facto standard of deploying new scalable applications.
  Companies chose cloud over on-premise or self-hosted environments, because they can deploy their applications more flexible, with higher and dynamically scalable performance, and because prices are very competitive~\cite{ToffettiMicroservices}.
  However, present cloud environments have to deal with heterogeneous resources and an ever-increasing scale.
  With this growing complexity failures are more likely to occur and software engineers have to design applications with that in mind.
  This can be achieved via replication, containment, isolation, and monitoring paired with responsive actions to failures~\cite{reactivemanifesto}.

  One way to realize containment and isolation of software components in a scalable way are microservice architectures.
  In this approach, the software application is decomposed along business domain boundaries into small, lightweight, autonomous services.
  Each service runs as its own application decoupled from the other services and acts as a scaling unit.
  Services communicate through lightweight REST APIs or asynchronous message queues.
  Microservice architectures embrace failure.
  If a service relies on another services, it is aware that the other service may not be available or the connection may be slow and the service can deal with the failures~\cite{microservices}.

  For those complex distributed software systems consisting of hundreds of microservices, deployment and management gets more complex as well.
  The service management can be simplified by executing the microservices isolated from each other in containers, such as Docker containers~\cite{docker}.
  Container orchestration tools, such as \gls{kubernetes}~\cite{kubernetes}, can further be used for the deployment, scaling, and management of the containerized distributed microservice applications.

  The increasing complexity of modern software systems motivated the development of self-adaptive systems.
  Those systems introduce an autonomous behavior that takes decisions at runtime and manages the complex underlying software system.
  This allows the software systems to adapt to unpredictable system changes and changing environments.
  Self-adaptive systems combine four self properties, as defined by \citeauthor{Ganek}~\cite{Ganek}:

  \begin{description}
    \item[self-configuring] The systems adapt automatically to dynamically changing environments (\enquote{on-the-fly}).
    \item[self-healing] The systems discover, diagnose, and react to failures reducing disruptions and enabling continuous availability.
    \item[self-optimization] Systems efficiently maximize resource utilization.
    \item[self-protection] Systems anticipate, detect, identify, and protect themselves from attacks.
  \end{description}

  This list has been continuously extended and the extended properties are now referred to as self-* properties~\cite{PsaierSurvey}.

  Self-healing is an integral part of self-adaptive systems and the focus of this paper.
  It combines properties of
  (i) fault-tolerant systems, which handle transient failures and mask permanent ones to ensure system availability,
  (ii) self-stabilizing systems, which are non-fault masking and converge to the legal state in a finite amount of time, and 
  (iii) survivable systems, which maintain essential services and recover non-essential ones after intrusions have been dealt with~\cite{PsaierSurvey}.
  A widely-used definition for self-healing systems is from \citeauthor{Ghosh}~\cite{Ghosh}:

  \begin{quote}
    The key focus [...] is that a self-healing system should recover from the abnormal (or \enquote{unhealthy}) state and return to the normative (\enquote{healthy}) state, and function as it was prior to disruption.
  \end{quote}

  This definition is very broad, but one can argue that the key aspect of self-healing systems are recovery oriented functionalities that bring the system back to the healthy state, which neither sole fault-tolerant systems nor sole survivable systems encompass~\cite{PsaierSurvey}.

  In cloud environments, self-healing techniques are already used in the form of approaches and tools that try to achieve continuous availability for cloud services, such as \gls{kubernetes}.
  Those tools detect disruptions, diagnose failures and recover from them by applying an appropriate strategy~\cite{PsaierSurvey}.
  While systems and software components can fail in various ways and research has come up with general failure classifications and resolutions~\cite[Tab.~1]{PsaierSurvey}, failures in cloud environments can be reduced to one failure: a node is unreachable.
  Although an unreachable node can have different root causes on the infrastructure level, the impact on the system is the same and we have no control about the infrastructure in a cloud deployment.
  This means that we have to find other ways besides repairing the infrastructure to heal from those failures.
  Node failures can be detected via heartbeat messages or latency metrics.

  \textbf{Contribution and Summary}